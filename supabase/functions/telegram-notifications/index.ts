import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

const TELEGRAM_BOT_TOKEN = Deno.env.get('TELEGRAM_BOT_TOKEN');
const SUPABASE_URL = Deno.env.get('SUPABASE_URL');
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');

if (!TELEGRAM_BOT_TOKEN) {
  throw new Error('TELEGRAM_BOT_TOKEN environment variable is required');
}

const supabase = createClient(SUPABASE_URL!, SUPABASE_SERVICE_ROLE_KEY!);

interface TradeNotificationPayload {
  trade_id: string;
  symbol: string;
  action: string;
  entry_price: number;
  stop_loss: number;
  take_profit: number;
  status: string;
  session_name: string;
  ai_confidence?: number;
  pips_result?: number;
  lot_size?: number;
  closed_at?: string;
  rejection_reason?: string;
}

async function sendTelegramMessage(chatId: number, text: string, parseMode = 'HTML') {
  try {
    const response = await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        chat_id: chatId,
        text: text,
        parse_mode: parseMode,
      }),
    });

    const result = await response.json();
    console.log(`Message sent to ${chatId}:`, result.ok ? 'Success' : result.description);
    
    return {
      success: result.ok,
      message_id: result.ok ? result.result.message_id : null,
      error: result.ok ? null : result.description
    };
  } catch (error) {
    console.error('Error sending telegram message:', error);
    return {
      success: false,
      message_id: null,
      error: error.message
    };
  }
}

function formatTradeOpenMessage(trade: TradeNotificationPayload): string {
  const direction = trade.action === 'BUY' ? 'ğŸ“ˆ' : 'ğŸ“‰';
  const confidence = trade.ai_confidence ? `${Math.round(trade.ai_confidence * 100)}%` : 'N/A';
  
  const riskReward = trade.take_profit && trade.stop_loss && trade.entry_price 
    ? Math.abs((trade.take_profit - trade.entry_price) / (trade.entry_price - trade.stop_loss)).toFixed(2)
    : 'N/A';

  return `
${direction} <b>NEW TRADE SIGNAL</b> ${direction}

<b>ğŸ’° Pair:</b> ${trade.symbol}
<b>ğŸ¯ Action:</b> ${trade.action}
<b>ğŸ“Š Entry:</b> ${trade.entry_price}
<b>ğŸ›¡ï¸ Stop Loss:</b> ${trade.stop_loss}
<b>ğŸ¯ Take Profit:</b> ${trade.take_profit}
<b>ğŸ“ˆ Risk/Reward:</b> 1:${riskReward}
<b>ğŸ¤– AI Confidence:</b> ${confidence}
<b>â° Session:</b> ${trade.session_name}
<b>ğŸ“¦ Lot Size:</b> ${trade.lot_size || 0.01}

<i>Generated by Oracle AI Auto Trader</i>
âš ï¸ <i>Always trade responsibly and manage your risk</i>
`;
}

function formatTradeCloseMessage(trade: TradeNotificationPayload): string {
  const pips = trade.pips_result || 0;
  const isProfit = pips > 0;
  const resultIcon = isProfit ? 'âœ…' : 'âŒ';
  const resultText = isProfit ? 'PROFIT' : 'LOSS';
  
  let closeReason = 'Trade completed';
  if (trade.rejection_reason) {
    closeReason = `Rejected: ${trade.rejection_reason}`;
  } else if (pips > 0) {
    closeReason = 'Take Profit hit';
  } else if (pips < 0) {
    closeReason = 'Stop Loss hit';
  }

  return `
${resultIcon} <b>TRADE CLOSED - ${resultText}</b> ${resultIcon}

<b>ğŸ’° Pair:</b> ${trade.symbol}
<b>ğŸ¯ Action:</b> ${trade.action}
<b>ğŸ“Š Entry:</b> ${trade.entry_price}
<b>ğŸ“Š Exit:</b> ${trade.status === 'CLOSED' ? 'Market close' : 'Signal close'}
<b>ğŸ“ˆ Result:</b> ${pips > 0 ? '+' : ''}${pips.toFixed(1)} pips
<b>ğŸ’¡ Reason:</b> ${closeReason}
<b>â° Session:</b> ${trade.session_name}
<b>ğŸ• Closed:</b> ${trade.closed_at ? new Date(trade.closed_at).toLocaleString() : 'Now'}

<i>Trade ID: ${trade.trade_id.substring(0, 8)}...</i>
`;
}

async function logNotification(chatId: number, tradeId: string, messageText: string, notificationType: string, result: any) {
  await supabase
    .from('telegram_notifications')
    .insert({
      chat_id: chatId,
      trade_id: tradeId,
      message_text: messageText,
      notification_type: notificationType,
      telegram_message_id: result.message_id,
      success: result.success,
      error_message: result.error
    });
}

async function sendTradeNotifications(trade: TradeNotificationPayload, notificationType: 'TRADE_OPEN' | 'TRADE_CLOSE') {
  console.log(`Sending ${notificationType} notifications for trade:`, trade.trade_id);

  // Get active subscribers
  const { data: subscribers, error } = await supabase
    .from('telegram_subscribers')
    .select('chat_id, subscribed_pairs')
    .eq('is_active', true);

  if (error) {
    console.error('Error fetching subscribers:', error);
    return { success: false, error: error.message };
  }

  if (!subscribers || subscribers.length === 0) {
    console.log('No active subscribers found');
    return { success: true, sent: 0 };
  }

  console.log(`Found ${subscribers.length} active subscribers`);

  let sent = 0;
  let failed = 0;

  for (const subscriber of subscribers) {
    // Check if subscriber wants this pair (empty array means all pairs)
    const wantsPair = subscriber.subscribed_pairs.length === 0 || 
                     subscriber.subscribed_pairs.includes(trade.symbol);

    if (!wantsPair) {
      console.log(`Subscriber ${subscriber.chat_id} not subscribed to ${trade.symbol}`);
      continue;
    }

    try {
      const message = notificationType === 'TRADE_OPEN' 
        ? formatTradeOpenMessage(trade)
        : formatTradeCloseMessage(trade);

      const result = await sendTelegramMessage(subscriber.chat_id, message);
      
      // Log the notification
      await logNotification(
        subscriber.chat_id, 
        trade.trade_id, 
        message, 
        notificationType, 
        result
      );

      if (result.success) {
        sent++;
      } else {
        failed++;
        console.error(`Failed to send to ${subscriber.chat_id}:`, result.error);
      }
    } catch (error) {
      failed++;
      console.error(`Error sending to subscriber ${subscriber.chat_id}:`, error);
    }
  }

  console.log(`Notification summary: ${sent} sent, ${failed} failed`);
  return { success: true, sent, failed };
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    if (req.method === 'POST') {
      const payload: TradeNotificationPayload = await req.json();
      console.log('Received notification payload:', payload);

      // Determine notification type based on trade status or payload
      let notificationType: 'TRADE_OPEN' | 'TRADE_CLOSE';
      
      if (payload.status === 'OPEN') {
        notificationType = 'TRADE_OPEN';
      } else if (payload.status === 'CLOSED' || payload.status === 'REJECTED') {
        notificationType = 'TRADE_CLOSE';
      } else {
        console.error('Unknown trade status:', payload.status);
        return new Response(JSON.stringify({ error: 'Invalid trade status' }), {
          status: 400,
          headers: { ...corsHeaders, 'Content-Type': 'application/json' }
        });
      }

      const result = await sendTradeNotifications(payload, notificationType);

      return new Response(JSON.stringify(result), {
        status: 200,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });

    } else if (req.method === 'GET') {
      // Health check
      return new Response(JSON.stringify({ 
        status: 'active',
        bot_token_configured: !!TELEGRAM_BOT_TOKEN 
      }), {
        status: 200,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      });

    } else {
      return new Response('Method not allowed', { 
        status: 405,
        headers: corsHeaders 
      });
    }

  } catch (error) {
    console.error('Error in telegram-notifications function:', error);
    return new Response(JSON.stringify({ error: error.message }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' }
    });
  }
});